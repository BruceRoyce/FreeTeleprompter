// src/validators.ts
function required() {
  return {
    validate: (input) => {
      const isValid2 = Array.isArray(input) ? input.length > 0 : Boolean(input);
      return isValid2 ? null : { isValid: isValid2, error: "required" };
    }
  };
}
function isValid(result) {
  if (typeof result === "object") {
    return result?.isValid !== false;
  }
  if (typeof result === "string") {
    return result.length > 0;
  }
  return true;
}
function resultError(result) {
  if (typeof result === "object") {
    return result.error;
  }
  return result;
}

// src/prompt-agent.ts
var kPrivateInstancier = Symbol("instancier");
var PromptAgent = class _PromptAgent {
  /**
   * The prompts answers queue.
   * When not empty, any prompt will be answered by the first answer in this list.
   */
  nextAnswers = [];
  /**
   * The shared PromptAgent.
   */
  static #this;
  static agent() {
    return this.#this ??= new _PromptAgent(kPrivateInstancier);
  }
  constructor(instancier) {
    if (instancier !== kPrivateInstancier) {
      throw new Error("Cannot instanciate PromptAgent, use PromptAgent.agent() instead");
    }
  }
  /**
   * Programmatically set the next answer for any prompt (`question()`, `confirm()`, `select()`)
   *
   * This is useful for testing.
   *
   * @example
   * ```js
   * const promptAgent = PromptAgent.agent();
   * promptAgent.nextAnswer("toto");
   *
   * const input = await question("what is your name?");
   * assert.equal(input, "toto");
   * ```
   */
  nextAnswer(value) {
    if (Array.isArray(value)) {
      this.nextAnswers.push(...value);
      return;
    }
    this.nextAnswers.push(value);
  }
};

// src/prompts/abstract.ts
import { EOL } from "node:os";
import readline from "node:readline";
import { Writable } from "node:stream";
import EventEmitter from "node:events";
import { stripVTControlCharacters } from "node:util";

// src/errors/abort.ts
var AbortError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "AbortError";
  }
};

// src/prompts/abstract.ts
function kNoopTransformer(input) {
  return input;
}
var AbstractPrompt = class _AbstractPrompt extends EventEmitter {
  stdin;
  stdout;
  message;
  signal;
  skip;
  history;
  agent;
  transformer = kNoopTransformer;
  rl;
  #signalHandler;
  constructor(options) {
    super();
    if (this.constructor === _AbstractPrompt) {
      throw new Error("AbstractPrompt can't be instantiated.");
    }
    const {
      stdin: input = process.stdin,
      stdout: output = process.stdout,
      message,
      signal,
      skip = false
    } = options;
    if (typeof message !== "string") {
      throw new TypeError(`message must be string, ${typeof message} given.`);
    }
    if (!output.isTTY) {
      Object.assign(output, {
        moveCursor: () => void 0,
        clearScreenDown: () => void 0
      });
    }
    this.stdin = input;
    this.stdout = output;
    this.message = message;
    this.signal = signal;
    this.skip = skip;
    this.history = [];
    this.agent = PromptAgent.agent();
    if (this.stdout.isTTY) {
      this.stdin.setRawMode(true);
    }
    this.rl = readline.createInterface({
      input,
      output: new Writable({
        write: (chunk, encoding, callback) => {
          if (chunk) {
            const transformed = this.transformer(
              Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk)
            );
            if (transformed !== null) {
              this.stdout.write(transformed, encoding);
            }
          }
          callback();
        }
      }),
      terminal: true
    });
    if (this.signal) {
      this.#signalHandler = () => {
        this.rl.close();
        for (let i = 0; i < this.history.length; i++) {
          this.clearLastLine();
        }
        this.emit("error", new AbortError("Prompt aborted"));
      };
      if (this.signal.aborted) {
        this.#signalHandler();
      }
      this.signal.addEventListener("abort", this.#signalHandler, { once: true });
    }
  }
  reset() {
    this.transformer = kNoopTransformer;
  }
  write(data) {
    const formattedData = stripVTControlCharacters(data).replace(EOL, "");
    if (formattedData) {
      this.history.push(formattedData);
    }
    return this.stdout.write(data);
  }
  clearLastLine() {
    const lastLine = this.history.pop();
    if (!lastLine) {
      return;
    }
    const lastLineRows = Math.ceil(stripVTControlCharacters(lastLine).length / this.stdout.columns);
    this.stdout.moveCursor(-this.stdout.columns, -lastLineRows);
    this.stdout.clearScreenDown();
  }
  destroy() {
    this.rl.close();
    if (this.signal) {
      this.signal.removeEventListener("abort", this.#signalHandler);
    }
  }
};

// src/prompts/question.ts
import { EOL as EOL2 } from "node:os";
import { styleText as styleText2 } from "node:util";

// src/utils.ts
import process2 from "node:process";
import { stripVTControlCharacters as stripVTControlCharacters2 } from "node:util";
var kLenSegmenter = new Intl.Segmenter();
function isUnicodeSupported() {
  if (process2.platform !== "win32") {
    return process2.env.TERM !== "linux";
  }
  return Boolean(process2.env.WT_SESSION) || Boolean(process2.env.TERMINUS_SUBLIME) || process2.env.ConEmuTask === "{cmd::Cmder}" || process2.env.TERM_PROGRAM === "Terminus-Sublime" || process2.env.TERM_PROGRAM === "vscode" || process2.env.TERM === "xterm-256color" || process2.env.TERM === "alacritty" || process2.env.TERMINAL_EMULATOR === "JetBrains-JediTerm";
}
function stringLength(string) {
  if (string === "") {
    return 0;
  }
  let length = 0;
  for (const _ of kLenSegmenter.segment(
    stripVTControlCharacters2(string)
  )) {
    length++;
  }
  return length;
}

// src/constants.ts
import { styleText } from "node:util";
var kMainSymbols = {
  tick: "\u2714",
  cross: "\u2716",
  pointer: "\u203A",
  previous: "\u2B61",
  next: "\u2B63",
  active: "\u25CF",
  inactive: "\u25CB"
};
var kFallbackSymbols = {
  tick: "\u221A",
  cross: "\xD7",
  pointer: ">",
  previous: "\u2191",
  next: "\u2193",
  active: "(+)",
  inactive: "(-)"
};
var kSymbols = isUnicodeSupported() || process.env.CI ? kMainSymbols : kFallbackSymbols;
var kPointer = styleText("gray", kSymbols.pointer);
var SYMBOLS = {
  QuestionMark: styleText(["blue", "bold"], "?"),
  Tick: styleText(["green", "bold"], kSymbols.tick),
  Cross: styleText(["red", "bold"], kSymbols.cross),
  Pointer: kPointer,
  Previous: kSymbols.previous,
  Next: kSymbols.next,
  ShowCursor: "\x1B[?25h",
  HideCursor: "\x1B[?25l",
  Active: styleText("cyan", kSymbols.active),
  Inactive: styleText("gray", kSymbols.inactive)
};

// src/prompts/question.ts
var QuestionPrompt = class extends AbstractPrompt {
  defaultValue;
  tip;
  questionSuffixError;
  answer;
  answerBuffer;
  #validators;
  #secure;
  #securePlaceholder = null;
  constructor(options) {
    const {
      defaultValue,
      validators = [],
      secure = false,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    if (defaultValue && typeof defaultValue !== "string") {
      throw new TypeError("defaultValue must be a string");
    }
    this.defaultValue = defaultValue;
    this.tip = this.defaultValue ? ` (${this.defaultValue})` : "";
    this.#validators = validators;
    if (typeof secure === "object") {
      this.#secure = true;
      this.#securePlaceholder = secure.placeholder;
    } else {
      this.#secure = Boolean(secure);
    }
    this.questionSuffixError = "";
  }
  #question() {
    return new Promise((resolve) => {
      const questionQuery = this.#getQuestionQuery();
      this.history.push(questionQuery);
      this.rl.question(questionQuery, (answer) => {
        this.history.push(questionQuery + answer);
        this.reset();
        resolve(answer);
      });
      if (this.#securePlaceholder !== null) {
        this.transformer = (input) => Buffer.from(this.#securePlaceholder.repeat(input.length), "utf-8");
      }
    });
  }
  #getQuestionQuery() {
    return `${styleText2("bold", `${SYMBOLS.QuestionMark} ${this.message}${this.tip}`)} ${this.questionSuffixError}`;
  }
  #setQuestionSuffixError(error) {
    const suffix = styleText2("red", `[${error}] `);
    this.questionSuffixError = suffix;
  }
  #writeAnswer() {
    const prefix = this.answer ? SYMBOLS.Tick : SYMBOLS.Cross;
    const answer = this.answer ?? "";
    const maskedAnswer = this.#securePlaceholder ? this.#securePlaceholder.repeat(answer.length) : answer;
    const stylizedAnswer = styleText2(
      "yellow",
      this.#secure && this.#securePlaceholder === null ? "CONFIDENTIAL" : maskedAnswer
    );
    this.write(`${prefix} ${styleText2("bold", this.message)} ${SYMBOLS.Pointer} ${stylizedAnswer}${EOL2}`);
  }
  #onQuestionAnswer() {
    const questionLineCount = Math.ceil(
      stringLength(this.#getQuestionQuery() + this.answer) / this.stdout.columns
    );
    this.stdout.moveCursor(-this.stdout.columns, -questionLineCount);
    this.stdout.clearScreenDown();
    for (const validator of this.#validators) {
      const validationResult = validator.validate(this.answer);
      if (isValid(validationResult) === false) {
        this.#setQuestionSuffixError(resultError(validationResult));
        this.answerBuffer = this.#question();
        return;
      }
    }
    this.answerBuffer = void 0;
    this.#writeAnswer();
  }
  async question() {
    if (this.skip) {
      this.destroy();
      return this.defaultValue ?? "";
    }
    return new Promise(async (resolve, reject) => {
      this.answer = this.agent.nextAnswers.shift();
      if (this.answer !== void 0) {
        this.#writeAnswer();
        this.destroy();
        resolve(this.answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.answer = await this.#question();
      if (this.answer === "" && this.defaultValue) {
        this.answer = this.defaultValue;
      }
      this.#onQuestionAnswer();
      while (this.answerBuffer !== void 0) {
        this.answer = await this.answerBuffer;
        this.#onQuestionAnswer();
      }
      this.destroy();
      resolve(this.answer);
    });
  }
};

// src/prompts/confirm.ts
import { EOL as EOL3 } from "node:os";
import { styleText as styleText3 } from "node:util";
var kToggleKeys = /* @__PURE__ */ new Set([
  "left",
  "right",
  "tab",
  "q",
  "a",
  "d",
  "h",
  "j",
  "k",
  "l",
  "space"
]);
var ConfirmPrompt = class extends AbstractPrompt {
  initial;
  selectedValue;
  fastAnswer;
  #boundKeyPressEvent;
  #boundExitEvent;
  constructor(options) {
    const {
      initial = false,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.initial = initial;
    this.selectedValue = initial;
  }
  #getHint() {
    const Yes = styleText3(["cyan", "bold", "underline"], "Yes");
    const No = styleText3(["cyan", "bold", "underline"], "No");
    return this.selectedValue ? `${Yes}/No` : `Yes/${No}`;
  }
  #render() {
    this.write(this.#getQuestionQuery());
  }
  #question() {
    return new Promise((resolve) => {
      const questionQuery = this.#getQuestionQuery();
      this.write(questionQuery);
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #onKeypress(resolve, _value, key) {
    this.stdout.moveCursor(
      -this.stdout.columns,
      -Math.floor(stringLength(this.#getQuestionQuery()) / this.stdout.columns)
    );
    this.stdout.clearScreenDown();
    if (key.name === "return") {
      resolve(this.selectedValue);
      return;
    }
    if (kToggleKeys.has(key.name ?? "")) {
      this.selectedValue = !this.selectedValue;
    }
    if (key.name === "y") {
      this.selectedValue = true;
      resolve(true);
      this.fastAnswer = true;
    } else if (key.name === "n") {
      this.selectedValue = false;
      resolve(false);
      this.fastAnswer = true;
    }
    if (!this.fastAnswer) {
      this.#render();
    }
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
  }
  #getQuestionQuery() {
    const query = styleText3("bold", `${SYMBOLS.QuestionMark} ${this.message}`);
    return `${query} ${this.#getHint()}`;
  }
  #onQuestionAnswer() {
    this.clearLastLine();
    this.stdout.moveCursor(
      -this.stdout.columns,
      -Math.floor(stringLength(this.#getQuestionQuery()) / this.stdout.columns)
    );
    this.stdout.clearScreenDown();
    this.write(`${this.selectedValue ? SYMBOLS.Tick : SYMBOLS.Cross} ${styleText3("bold", this.message)}${EOL3}`);
  }
  async confirm() {
    if (this.skip) {
      this.destroy();
      return this.initial;
    }
    return new Promise(async (resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        this.selectedValue = answer;
        this.#onQuestionAnswer();
        this.destroy();
        resolve(answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      try {
        await this.#question();
        this.#onQuestionAnswer();
        resolve(this.selectedValue);
      } finally {
        this.write(SYMBOLS.ShowCursor);
        this.#onProcessExit();
        process.off("exit", this.#boundExitEvent);
        this.destroy();
      }
    });
  }
};

// src/prompts/select.ts
import { EOL as EOL4 } from "node:os";
import { styleText as styleText4 } from "node:util";
var kRequiredChoiceProperties = ["label", "value"];
var SelectPrompt = class extends AbstractPrompt {
  #boundExitEvent = () => void 0;
  #boundKeyPressEvent = () => void 0;
  #validators;
  activeIndex = 0;
  questionMessage;
  autocompleteValue = "";
  options;
  lastRender;
  get choices() {
    return this.options.choices;
  }
  get filteredChoices() {
    if (!(this.options.autocomplete && this.autocompleteValue.length > 0)) {
      return this.choices;
    }
    const isCaseSensitive = this.options.caseSensitive;
    const autocompleteValue = isCaseSensitive ? this.autocompleteValue : this.autocompleteValue.toLowerCase();
    return this.choices.filter((choice) => this.#filterChoice(choice, autocompleteValue, isCaseSensitive));
  }
  #filterChoice(choice, autocompleteValue, isCaseSensitive = false) {
    const choiceValue = typeof choice === "string" ? isCaseSensitive ? choice : choice.toLowerCase() : isCaseSensitive ? choice.label : choice.label.toLowerCase();
    if (autocompleteValue.includes(" ")) {
      return this.#filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive);
    }
    return choiceValue.includes(autocompleteValue);
  }
  #filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive) {
    return autocompleteValue.split(" ").every((word) => {
      const wordValue = isCaseSensitive ? word : word.toLowerCase();
      return choiceValue.includes(wordValue) || choiceValue.includes(autocompleteValue);
    });
  }
  get longestChoice() {
    return Math.max(...this.filteredChoices.map((choice) => {
      if (typeof choice === "string") {
        return choice.length;
      }
      return choice.label.length;
    }));
  }
  constructor(options) {
    const {
      choices,
      validators = [],
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.options = options;
    if (!choices?.length) {
      this.destroy();
      throw new TypeError("Missing required param: choices");
    }
    this.#validators = validators;
    for (const choice of choices) {
      if (typeof choice === "string") {
        continue;
      }
      for (const prop of kRequiredChoiceProperties) {
        if (!choice[prop]) {
          this.destroy();
          throw new TypeError(`Missing ${prop} for choice ${JSON.stringify(choice)}`);
        }
      }
    }
  }
  #getFormattedChoice(choiceIndex) {
    const choice = this.filteredChoices[choiceIndex];
    if (typeof choice === "string") {
      return { value: choice, label: choice };
    }
    return choice;
  }
  #getVisibleChoices() {
    const maxVisible = this.options.maxVisible || 8;
    let startIndex = Math.min(this.filteredChoices.length - maxVisible, this.activeIndex - Math.floor(maxVisible / 2));
    if (startIndex < 0) {
      startIndex = 0;
    }
    const endIndex = Math.min(startIndex + maxVisible, this.filteredChoices.length);
    return { startIndex, endIndex };
  }
  #showChoices() {
    const { startIndex, endIndex } = this.#getVisibleChoices();
    this.lastRender = { startIndex, endIndex };
    if (this.options.autocomplete) {
      this.write(`${SYMBOLS.Pointer} ${this.autocompleteValue}${EOL4}`);
    }
    for (let choiceIndex = startIndex; choiceIndex < endIndex; choiceIndex++) {
      const choice = this.#getFormattedChoice(choiceIndex);
      const isChoiceSelected = choiceIndex === this.activeIndex;
      const showPreviousChoicesArrow = startIndex > 0 && choiceIndex === startIndex;
      const showNextChoicesArrow = endIndex < this.filteredChoices.length && choiceIndex === endIndex - 1;
      let prefixArrow = " ";
      if (showPreviousChoicesArrow) {
        prefixArrow = SYMBOLS.Previous;
      } else if (showNextChoicesArrow) {
        prefixArrow = SYMBOLS.Next;
      }
      const prefix = `${prefixArrow}${isChoiceSelected ? `${SYMBOLS.Pointer} ` : "  "}`;
      const formattedLabel = choice.label.padEnd(
        this.longestChoice < 10 ? this.longestChoice : 0
      );
      const formattedDescription = choice.description ? ` - ${choice.description}` : "";
      const styles = isChoiceSelected ? ["white", "bold"] : ["gray"];
      const str = `${prefix}${styleText4(styles, `${formattedLabel}${formattedDescription}`)}${EOL4}`;
      this.write(str);
    }
  }
  #showAnsweredQuestion(label) {
    const symbolPrefix = label === "" ? SYMBOLS.Cross : SYMBOLS.Tick;
    const prefix = `${symbolPrefix} ${styleText4("bold", this.message)} ${SYMBOLS.Pointer}`;
    const formattedChoice = styleText4("yellow", label);
    this.write(`${prefix} ${formattedChoice}${EOL4}`);
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
    this.stdout.moveCursor(-this.stdout.columns, 0);
    this.stdout.clearScreenDown();
    this.write(SYMBOLS.ShowCursor);
  }
  #onKeypress(...args) {
    const [resolve, render, , key] = args;
    if (key.name === "up") {
      this.activeIndex = this.activeIndex === 0 ? this.filteredChoices.length - 1 : this.activeIndex - 1;
      render();
    } else if (key.name === "down") {
      this.activeIndex = this.activeIndex === this.filteredChoices.length - 1 ? 0 : this.activeIndex + 1;
      render();
    } else if (key.name === "return") {
      const choice = this.filteredChoices[this.activeIndex] || "";
      const label = typeof choice === "string" ? choice : choice.label;
      const value = typeof choice === "string" ? choice : choice.value;
      for (const validator of this.#validators) {
        const validationResult = validator.validate(value);
        if (isValid(validationResult) === false) {
          render({ error: resultError(validationResult) });
          return;
        }
      }
      render({ clearRender: true });
      if (!this.options.ignoreValues?.includes(value)) {
        this.#showAnsweredQuestion(label);
      }
      this.write(SYMBOLS.ShowCursor);
      this.destroy();
      this.#onProcessExit();
      process.off("exit", this.#boundExitEvent);
      resolve(value);
    } else {
      if (!key.ctrl && this.options.autocomplete) {
        this.activeIndex = 0;
        if (key.name === "backspace" && this.autocompleteValue.length > 0) {
          this.autocompleteValue = this.autocompleteValue.slice(0, -1);
        } else if (key.name !== "backspace") {
          this.autocompleteValue += key.sequence;
        }
      }
      render();
    }
  }
  async select() {
    if (this.skip) {
      this.destroy();
      const answer = this.options.choices[0];
      return typeof answer === "string" ? answer : answer.value;
    }
    return new Promise((resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        this.#showAnsweredQuestion(answer);
        this.destroy();
        resolve(answer);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      this.#showQuestion();
      const render = (options = {}) => {
        const {
          initialRender = false,
          clearRender = false,
          error = null
        } = options;
        if (!initialRender) {
          let linesToClear = this.lastRender.endIndex - this.lastRender.startIndex;
          while (linesToClear > 0) {
            this.clearLastLine();
            linesToClear--;
          }
          if (this.options.autocomplete) {
            let linesToClear2 = Math.ceil(
              stringLength(`${SYMBOLS.Pointer} ${this.autocompleteValue}`) / this.stdout.columns
            );
            while (linesToClear2 > 0) {
              this.clearLastLine();
              linesToClear2--;
            }
          }
        }
        if (clearRender) {
          const questionLineCount = Math.ceil(
            stringLength(this.questionMessage) / this.stdout.columns
          );
          this.stdout.moveCursor(-this.stdout.columns, -(1 + questionLineCount));
          this.stdout.clearScreenDown();
          return;
        }
        if (error) {
          const linesToClear = Math.ceil(stringLength(this.questionMessage) / this.stdout.columns) + 1;
          this.stdout.moveCursor(0, -linesToClear);
          this.stdout.clearScreenDown();
          this.#showQuestion(error);
        }
        this.#showChoices();
      };
      render({ initialRender: true });
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve, render);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #showQuestion(error = null) {
    let hint = "";
    if (error) {
      hint = ` ${hint.length > 0 ? " " : ""}${styleText4(["red", "bold"], `[${error}]`)}`;
    }
    this.questionMessage = `${SYMBOLS.QuestionMark} ${styleText4("bold", this.message)}${hint}`;
    this.write(`${this.questionMessage}${EOL4}`);
  }
};

// src/prompts/multiselect.ts
import { EOL as EOL5 } from "node:os";
import { styleText as styleText5 } from "node:util";
var kRequiredChoiceProperties2 = ["label", "value"];
var MultiselectPrompt = class extends AbstractPrompt {
  #boundExitEvent = () => void 0;
  #boundKeyPressEvent = () => void 0;
  #validators;
  #showHint;
  activeIndex = 0;
  selectedIndexes = /* @__PURE__ */ new Set();
  questionMessage;
  autocompleteValue = "";
  options;
  lastRender;
  get choices() {
    return this.options.choices;
  }
  get filteredChoices() {
    if (!(this.options.autocomplete && this.autocompleteValue.length > 0)) {
      return this.choices;
    }
    const isCaseSensitive = this.options.caseSensitive;
    const autocompleteValue = isCaseSensitive ? this.autocompleteValue : this.autocompleteValue.toLowerCase();
    return this.choices.filter((choice) => this.#filterChoice(choice, autocompleteValue, isCaseSensitive));
  }
  #filterChoice(choice, autocompleteValue, isCaseSensitive = false) {
    const choiceValue = typeof choice === "string" ? isCaseSensitive ? choice : choice.toLowerCase() : isCaseSensitive ? choice.label : choice.label.toLowerCase();
    if (autocompleteValue.includes(" ")) {
      return this.#filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive);
    }
    return choiceValue.includes(autocompleteValue);
  }
  #filterMultipleWords(choiceValue, autocompleteValue, isCaseSensitive) {
    return autocompleteValue.split(" ").every((word) => {
      const wordValue = isCaseSensitive ? word : word.toLowerCase();
      return choiceValue.includes(wordValue) || choiceValue.includes(autocompleteValue);
    });
  }
  get longestChoice() {
    return Math.max(...this.filteredChoices.map((choice) => {
      if (typeof choice === "string") {
        return choice.length;
      }
      return choice.label.length;
    }));
  }
  constructor(options) {
    const {
      choices,
      preSelectedChoices = [],
      validators = [],
      showHint = true,
      ...baseOptions
    } = options;
    super({ ...baseOptions });
    this.options = options;
    if (!choices?.length) {
      this.destroy();
      throw new TypeError("Missing required param: choices");
    }
    this.#validators = validators;
    this.#showHint = showHint;
    for (const choice of choices) {
      if (typeof choice === "string") {
        continue;
      }
      for (const prop of kRequiredChoiceProperties2) {
        if (!choice[prop]) {
          this.destroy();
          throw new TypeError(`Missing ${prop} for choice ${JSON.stringify(choice)}`);
        }
      }
    }
    for (const choice of preSelectedChoices) {
      const choiceIndex = this.filteredChoices.findIndex((item) => {
        if (typeof item === "string") {
          return item === choice;
        }
        return item.value === choice;
      });
      if (choiceIndex === -1) {
        this.destroy();
        throw new Error(`Invalid pre-selected choice: ${typeof choice === "string" ? choice : choice.value}`);
      }
      this.selectedIndexes.add(choiceIndex);
    }
  }
  #getFormattedChoice(choiceIndex) {
    const choice = this.filteredChoices[choiceIndex];
    if (typeof choice === "string") {
      return { value: choice, label: choice };
    }
    return choice;
  }
  #getVisibleChoices() {
    const maxVisible = this.options.maxVisible || 8;
    let startIndex = Math.min(this.filteredChoices.length - maxVisible, this.activeIndex - Math.floor(maxVisible / 2));
    if (startIndex < 0) {
      startIndex = 0;
    }
    const endIndex = Math.min(startIndex + maxVisible, this.filteredChoices.length);
    return { startIndex, endIndex };
  }
  #showChoices() {
    const { startIndex, endIndex } = this.#getVisibleChoices();
    this.lastRender = { startIndex, endIndex };
    if (this.options.autocomplete) {
      this.write(`${SYMBOLS.Pointer} ${this.autocompleteValue}${EOL5}`);
    }
    for (let choiceIndex = startIndex; choiceIndex < endIndex; choiceIndex++) {
      const choice = this.#getFormattedChoice(choiceIndex);
      const isChoiceActive = choiceIndex === this.activeIndex;
      const isChoiceSelected = this.selectedIndexes.has(choiceIndex);
      const showPreviousChoicesArrow = startIndex > 0 && choiceIndex === startIndex;
      const showNextChoicesArrow = endIndex < this.filteredChoices.length && choiceIndex === endIndex - 1;
      let prefixArrow = "  ";
      if (showPreviousChoicesArrow) {
        prefixArrow = SYMBOLS.Previous + " ";
      } else if (showNextChoicesArrow) {
        prefixArrow = SYMBOLS.Next + " ";
      }
      const prefix = `${prefixArrow}${isChoiceSelected ? SYMBOLS.Active : SYMBOLS.Inactive}`;
      const formattedLabel = choice.label.padEnd(
        this.longestChoice < 10 ? this.longestChoice : 0
      );
      const formattedDescription = choice.description ? ` - ${choice.description}` : "";
      const styles = isChoiceActive ? ["white", "bold"] : ["gray"];
      const str = `${prefix} ${styleText5(styles, `${formattedLabel}${formattedDescription}`)}${EOL5}`;
      this.write(str);
    }
  }
  #showAnsweredQuestion(choices, isAgentAnswer = false) {
    const prefixSymbol = this.selectedIndexes.size === 0 && !isAgentAnswer ? SYMBOLS.Cross : SYMBOLS.Tick;
    const prefix = `${prefixSymbol} ${styleText5("bold", this.message)} ${SYMBOLS.Pointer}`;
    const formattedChoice = styleText5("yellow", choices);
    this.write(`${prefix}${choices ? ` ${formattedChoice}` : ""}${EOL5}`);
  }
  #selectedChoices() {
    return [...this.selectedIndexes].reduce(
      (acc, index) => {
        const choice = this.filteredChoices[index];
        if (typeof choice === "string") {
          acc.values.push(choice);
          acc.labels.push(choice);
        } else {
          acc.values.push(choice.value);
          acc.labels.push(choice.label);
        }
        return acc;
      },
      {
        values: [],
        labels: []
      }
    );
  }
  #onProcessExit() {
    this.stdin.off("keypress", this.#boundKeyPressEvent);
    this.stdout.moveCursor(-this.stdout.columns, 0);
    this.stdout.clearScreenDown();
    this.write(SYMBOLS.ShowCursor);
  }
  #onKeypress(...args) {
    const [resolve, render, , key] = args;
    if (key.name === "up") {
      this.activeIndex = this.activeIndex === 0 ? this.filteredChoices.length - 1 : this.activeIndex - 1;
      render();
    } else if (key.name === "down") {
      this.activeIndex = this.activeIndex === this.filteredChoices.length - 1 ? 0 : this.activeIndex + 1;
      render();
    } else if (key.ctrl && key.name === "a") {
      this.selectedIndexes = this.selectedIndexes.size === this.filteredChoices.length ? /* @__PURE__ */ new Set() : new Set(this.filteredChoices.map((_, index) => index));
      render();
    } else if (key.name === "right") {
      this.selectedIndexes.add(this.activeIndex);
      render();
    } else if (key.name === "left") {
      this.selectedIndexes = new Set([...this.selectedIndexes].filter((index) => index !== this.activeIndex));
      render();
    } else if (key.name === "return") {
      const { values, labels } = this.#selectedChoices();
      for (const validator of this.#validators) {
        const validationResult = validator.validate(values);
        if (isValid(validationResult) === false) {
          render({ error: resultError(validationResult) });
          return;
        }
      }
      render({ clearRender: true });
      this.#showAnsweredQuestion(labels.join(", "));
      this.write(SYMBOLS.ShowCursor);
      this.destroy();
      this.#onProcessExit();
      process.off("exit", this.#boundExitEvent);
      resolve(values);
    } else {
      if (!key.ctrl && this.options.autocomplete) {
        this.selectedIndexes.clear();
        this.activeIndex = 0;
        if (key.name === "backspace" && this.autocompleteValue.length > 0) {
          this.autocompleteValue = this.autocompleteValue.slice(0, -1);
        } else if (key.name !== "backspace") {
          this.autocompleteValue += key.sequence;
        }
      }
      render();
    }
  }
  async multiselect() {
    if (this.skip) {
      this.destroy();
      const { values } = this.#selectedChoices();
      return values;
    }
    return new Promise((resolve, reject) => {
      const answer = this.agent.nextAnswers.shift();
      if (answer !== void 0) {
        const formatedAnser = Array.isArray(answer) ? answer.join(", ") : answer;
        this.#showAnsweredQuestion(formatedAnser, true);
        this.destroy();
        resolve(Array.isArray(answer) ? answer : [answer]);
        return;
      }
      this.once("error", (error) => {
        reject(error);
      });
      this.write(SYMBOLS.HideCursor);
      this.#showQuestion();
      const render = (options = {}) => {
        const {
          initialRender = false,
          clearRender = false,
          error = null
        } = options;
        if (!initialRender) {
          let linesToClear = this.lastRender.endIndex - this.lastRender.startIndex;
          while (linesToClear > 0) {
            this.clearLastLine();
            linesToClear--;
          }
          if (this.options.autocomplete) {
            let linesToClear2 = Math.ceil(
              stringLength(`${SYMBOLS.Pointer} ${this.autocompleteValue}`) / this.stdout.columns
            );
            while (linesToClear2 > 0) {
              this.clearLastLine();
              linesToClear2--;
            }
          }
        }
        if (clearRender) {
          const questionLineCount = Math.ceil(
            stringLength(this.questionMessage) / this.stdout.columns
          );
          this.stdout.moveCursor(-this.stdout.columns, -(1 + questionLineCount));
          this.stdout.clearScreenDown();
          return;
        }
        if (error) {
          const linesToClear = Math.ceil(stringLength(this.questionMessage) / this.stdout.columns) + 1;
          this.stdout.moveCursor(0, -linesToClear);
          this.stdout.clearScreenDown();
          this.#showQuestion(error);
        }
        this.#showChoices();
      };
      render({ initialRender: true });
      this.#boundKeyPressEvent = this.#onKeypress.bind(this, resolve, render);
      this.stdin.on("keypress", this.#boundKeyPressEvent);
      this.#boundExitEvent = this.#onProcessExit.bind(this);
      process.once("exit", this.#boundExitEvent);
    });
  }
  #showQuestion(error = null) {
    let hint = this.#showHint ? styleText5(
      "gray",
      // eslint-disable-next-line @stylistic/max-len
      `(Press ${styleText5("bold", "<Ctrl+A>")} to toggle all, ${styleText5("bold", "<Left/Right>")} to toggle, ${styleText5("bold", "<Return>")} to submit)`
    ) : "";
    if (error) {
      hint += `${hint.length > 0 ? " " : ""}${styleText5(["red", "bold"], `[${error}]`)}`;
    }
    this.questionMessage = `${SYMBOLS.QuestionMark} ${styleText5("bold", this.message)}${hint.length > 0 ? ` ${hint}` : ""}`;
    this.write(`${this.questionMessage}${EOL5}`);
  }
};

// src/index.ts
function question(message, options = {}) {
  return new QuestionPrompt(
    { ...options, message }
  ).question();
}
function select(message, options) {
  return new SelectPrompt(
    { ...options, message }
  ).select();
}
function confirm(message, options = {}) {
  return new ConfirmPrompt(
    { ...options, message }
  ).confirm();
}
function multiselect(message, options) {
  return new MultiselectPrompt(
    { ...options, message }
  ).multiselect();
}
export {
  PromptAgent,
  confirm,
  multiselect,
  question,
  required,
  select
};
