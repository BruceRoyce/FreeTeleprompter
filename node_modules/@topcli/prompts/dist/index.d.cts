type ValidResponseObject = {
    isValid?: true;
};
type InvalidResponseObject = {
    isValid: false;
    error: string;
};
type ValidationResponseObject = ValidResponseObject | InvalidResponseObject;
type ValidationResponse = InvalidResponse | ValidResponse;
type InvalidResponse = string | InvalidResponseObject;
type ValidResponse = null | undefined | true | ValidResponseObject;
interface PromptValidator<T extends string | string[]> {
    validate: (input: T) => ValidationResponse;
}
declare function required(): PromptValidator<any>;

declare class PromptAgent<T = string> {
    #private;
    /**
     * The prompts answers queue.
     * When not empty, any prompt will be answered by the first answer in this list.
     */
    nextAnswers: T[];
    static agent<T>(): PromptAgent<T>;
    constructor(instancier: symbol);
    /**
     * Programmatically set the next answer for any prompt (`question()`, `confirm()`, `select()`)
     *
     * This is useful for testing.
     *
     * @example
     * ```js
     * const promptAgent = PromptAgent.agent();
     * promptAgent.nextAnswer("toto");
     *
     * const input = await question("what is your name?");
     * assert.equal(input, "toto");
     * ```
     */
    nextAnswer(value: T): void;
}

interface Choice<T extends string> {
    value: T;
    label: string;
    description?: string;
}

type Stdin = NodeJS.ReadStream & {
    fd: 0;
};
type Stdout = NodeJS.WriteStream & {
    fd: 1;
};
interface AbstractPromptOptions {
    stdin?: Stdin;
    stdout?: Stdout;
    message: string;
    skip?: boolean;
    signal?: AbortSignal;
}

interface QuestionOptions extends AbstractPromptOptions {
    defaultValue?: string;
    validators?: PromptValidator<string>[];
    secure?: boolean | {
        placeholder: string;
    };
}

interface ConfirmOptions extends AbstractPromptOptions {
    initial?: boolean;
}

interface SelectOptions<T extends string> extends AbstractPromptOptions {
    choices: (Choice<T> | T)[];
    maxVisible?: number;
    ignoreValues?: (T | number | boolean)[];
    validators?: PromptValidator<string>[];
    autocomplete?: boolean;
    caseSensitive?: boolean;
}

interface MultiselectOptions<T extends string> extends AbstractPromptOptions {
    choices: (Choice<T> | T)[];
    maxVisible?: number;
    preSelectedChoices?: (Choice<T> | T)[];
    validators?: PromptValidator<string[]>[];
    autocomplete?: boolean;
    caseSensitive?: boolean;
    showHint?: boolean;
}

declare function question(message: string, options?: Omit<QuestionOptions, "message">): Promise<string>;
declare function select<T extends string>(message: string, options: Omit<SelectOptions<T>, "message">): Promise<T>;
declare function confirm(message: string, options?: Omit<ConfirmOptions, "message">): Promise<boolean>;
declare function multiselect<T extends string>(message: string, options: Omit<MultiselectOptions<T>, "message">): Promise<T[]>;

export { type AbstractPromptOptions, type Choice, type ConfirmOptions, type InvalidResponse, type InvalidResponseObject, type MultiselectOptions, PromptAgent, type PromptValidator, type QuestionOptions, type SelectOptions, type ValidResponse, type ValidResponseObject, type ValidationResponse, type ValidationResponseObject, confirm, multiselect, question, required, select };
